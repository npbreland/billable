#!/usr/bin/env python3
import sqlite3
import sys
import os
from datetime import datetime
from pathlib import Path
import tty
import termios

DB_PATH = Path.home() / '.billable_hours.db'

def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS clients
                 (id INTEGER PRIMARY KEY, name TEXT UNIQUE)''')
    c.execute('''CREATE TABLE IF NOT EXISTS periods
                 (id INTEGER PRIMARY KEY, client_id INTEGER, 
                  start_time TEXT, end_time TEXT,
                  FOREIGN KEY(client_id) REFERENCES clients(id))''')
    c.execute('''CREATE TABLE IF NOT EXISTS sessions
                 (id INTEGER PRIMARY KEY, period_id INTEGER,
                  start_time TEXT, end_time TEXT,
                  FOREIGN KEY(period_id) REFERENCES periods(id))''')
    conn.commit()
    conn.close()

def add_client(name):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    try:
        c.execute("INSERT INTO clients (name) VALUES (?)", (name,))
        conn.commit()
        print(f"✓ Client '{name}' added")
    except sqlite3.IntegrityError:
        print(f"✗ Client '{name}' already exists")
    conn.close()

def list_clients():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT id, name FROM clients ORDER BY name")
    clients = c.fetchall()
    conn.close()
    
    if not clients:
        print("No clients found. Add one with: billable add <client_name>")
        return
    
    print("\nClients:")
    for cid, name in clients:
        print(f"  {cid}. {name}")
    print()

def start_period(client_name):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("SELECT id FROM clients WHERE name = ?", (client_name,))
    client = c.fetchone()
    
    if not client:
        print(f"✗ Client '{client_name}' not found")
        conn.close()
        return
    
    client_id = client[0]
    
    # Check for active period
    c.execute("""SELECT id FROM periods 
                 WHERE client_id = ? AND end_time IS NULL""", (client_id,))
    if c.fetchone():
        print(f"✗ Client '{client_name}' already has an active billing period")
        conn.close()
        return
    
    now = datetime.now().isoformat()
    c.execute("INSERT INTO periods (client_id, start_time) VALUES (?, ?)", 
              (client_id, now))
    conn.commit()
    print(f"✓ Started billing period for '{client_name}'")
    conn.close()

def toggle_session_internal(client_name):
    """Internal function to toggle session state"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("SELECT id FROM clients WHERE name = ?", (client_name,))
    client = c.fetchone()
    
    if not client:
        conn.close()
        return None
    
    client_id = client[0]
    
    # Get active period
    c.execute("""SELECT id FROM periods 
                 WHERE client_id = ? AND end_time IS NULL""", (client_id,))
    period = c.fetchone()
    
    if not period:
        conn.close()
        return None
    
    period_id = period[0]
    
    # Check for active session
    c.execute("""SELECT id FROM sessions 
                 WHERE period_id = ? AND end_time IS NULL""", (period_id,))
    active_session = c.fetchone()
    
    now = datetime.now().isoformat()
    
    if active_session:
        # Pause - end the current session
        c.execute("UPDATE sessions SET end_time = ? WHERE id = ?", 
                  (now, active_session[0]))
        conn.commit()
        conn.close()
        return "paused"
    else:
        # Start - create new session
        c.execute("INSERT INTO sessions (period_id, start_time) VALUES (?, ?)", 
                  (period_id, now))
        conn.commit()
        conn.close()
        return "running"

def get_session_state(client_name):
    """Check if timer is currently running"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("SELECT id FROM clients WHERE name = ?", (client_name,))
    client = c.fetchone()
    
    if not client:
        conn.close()
        return None
    
    client_id = client[0]
    
    # Get active period
    c.execute("""SELECT id FROM periods 
                 WHERE client_id = ? AND end_time IS NULL""", (client_id,))
    period = c.fetchone()
    
    if not period:
        conn.close()
        return None
    
    period_id = period[0]
    
    # Check for active session
    c.execute("""SELECT id FROM sessions 
                 WHERE period_id = ? AND end_time IS NULL""", (period_id,))
    active_session = c.fetchone()
    conn.close()
    
    return "running" if active_session else "paused"

def getch():
    """Get a single character from stdin"""
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    return ch

def format_time(hours):
    """Format hours as HH:MM:SS"""
    total_seconds = int(hours * 3600)
    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    seconds = total_seconds % 60
    return f"{hours:02d}:{minutes:02d}:{seconds:02d}"

def get_period_total_hours(client_name):
    """Calculate total hours for the active period"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("SELECT id FROM clients WHERE name = ?", (client_name,))
    client = c.fetchone()
    
    if not client:
        conn.close()
        return 0
    
    client_id = client[0]
    
    # Get active period
    c.execute("""SELECT id FROM periods 
                 WHERE client_id = ? AND end_time IS NULL""", (client_id,))
    period = c.fetchone()
    
    if not period:
        conn.close()
        return 0
    
    period_id = period[0]
    
    # Calculate hours from completed sessions
    c.execute("""
        SELECT start_time, end_time FROM sessions
        WHERE period_id = ? AND end_time IS NOT NULL
        ORDER BY start_time
    """, (period_id,))
    
    sessions = c.fetchall()
    total_hours = sum(calculate_hours(s[0], s[1]) for s in sessions)
    
    # Add current running session if any
    c.execute("""
        SELECT start_time FROM sessions
        WHERE period_id = ? AND end_time IS NULL
    """, (period_id,))
    
    running_session = c.fetchone()
    if running_session:
        total_hours += calculate_hours(running_session[0], datetime.now().isoformat())
    
    conn.close()
    return total_hours

def display_status(client_name):
    """Display the timer UI"""
    state = get_session_state(client_name)
    total_hours = get_period_total_hours(client_name)
    
    # Clear screen and show header
    print("\033[2J\033[H")  # Clear screen and move cursor to top
    print("="*60)
    print(f"  Billable Timer: {client_name}")
    print("="*60)
    print("\n  Controls:")
    print("    [ENTER]  - Play/Pause timer")
    print("    [CTRL+D] - End session and exit")
    print("\n" + "-"*60 + "\n")
    
    if state == "running":
        print("  Status: ▶  RUNNING")
    else:
        print("  Status: ⏸  PAUSED")
    
    print(f"\n  Total Time: {format_time(total_hours)}")
    
    print("\n" + "-"*60)
    print("\nPress ENTER to play/pause...")

def toggle_session(client_name):
    """Interactive toggle mode - press enter to toggle, Ctrl+D to exit"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("SELECT id FROM clients WHERE name = ?", (client_name,))
    client = c.fetchone()
    
    if not client:
        print(f"✗ Client '{client_name}' not found")
        conn.close()
        return
    
    client_id = client[0]
    
    # Get or check active period
    c.execute("""SELECT id FROM periods 
                 WHERE client_id = ? AND end_time IS NULL""", (client_id,))
    period = c.fetchone()
    
    if not period:
        print(f"✗ No active billing period for '{client_name}'")
        print(f"Start one with: billable start \"{client_name}\"")
        conn.close()
        return
    
    conn.close()
    
    # Set stdin to non-blocking for running state
    import fcntl
    import time
    
    fd = sys.stdin.fileno()
    old_flags = fcntl.fcntl(fd, fcntl.F_GETFL)
    
    # Initial display
    display_status(client_name)
    
    try:
        last_update = time.time()
        
        while True:
            state = get_session_state(client_name)
            
            if state == "running":
                # Non-blocking mode when running
                fcntl.fcntl(fd, fcntl.F_SETFL, old_flags | os.O_NONBLOCK)
                
                try:
                    line = sys.stdin.readline()
                    if line:
                        # Toggle on enter
                        toggle_session_internal(client_name)
                        display_status(client_name)
                        last_update = time.time()
                except IOError:
                    # No input available
                    pass
                
                # Update display every second
                current_time = time.time()
                if current_time - last_update >= 1:
                    display_status(client_name)
                    last_update = current_time
                
                time.sleep(0.1)  # Small sleep to prevent busy waiting
                
            else:
                # Blocking mode when paused
                fcntl.fcntl(fd, fcntl.F_SETFL, old_flags)
                
                try:
                    line = sys.stdin.readline()
                    if line:
                        toggle_session_internal(client_name)
                        display_status(client_name)
                        last_update = time.time()
                    else:
                        # EOF (Ctrl+D)
                        print("\n\n✓ Session ended\n")
                        break
                except EOFError:
                    print("\n\n✓ Session ended\n")
                    break
                
    except KeyboardInterrupt:
        print("\n\n✓ Session ended\n")
    finally:
        # Restore original flags
        fcntl.fcntl(fd, fcntl.F_SETFL, old_flags)

def end_period(client_name):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("SELECT id FROM clients WHERE name = ?", (client_name,))
    client = c.fetchone()
    
    if not client:
        print(f"✗ Client '{client_name}' not found")
        conn.close()
        return
    
    client_id = client[0]
    
    # Get active period
    c.execute("""SELECT id FROM periods 
                 WHERE client_id = ? AND end_time IS NULL""", (client_id,))
    period = c.fetchone()
    
    if not period:
        print(f"✗ No active billing period for '{client_name}'")
        conn.close()
        return
    
    period_id = period[0]
    
    # End any active session
    now = datetime.now().isoformat()
    c.execute("""UPDATE sessions SET end_time = ? 
                 WHERE period_id = ? AND end_time IS NULL""", (now, period_id))
    
    # End the period
    c.execute("UPDATE periods SET end_time = ? WHERE id = ?", (now, period_id))
    conn.commit()
    print(f"✓ Ended billing period for '{client_name}'")
    conn.close()

def calculate_hours(start, end):
    start_dt = datetime.fromisoformat(start)
    end_dt = datetime.fromisoformat(end)
    return (end_dt - start_dt).total_seconds() / 3600

def list_hours():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("""
        SELECT c.name, p.id, p.start_time, p.end_time
        FROM clients c
        LEFT JOIN periods p ON c.id = p.client_id
        ORDER BY c.name, p.start_time
    """)
    
    periods = c.fetchall()
    
    client_totals = {}
    current_client = None
    
    for client_name, period_id, start, end in periods:
        if client_name not in client_totals:
            client_totals[client_name] = {'total': 0, 'periods': []}
        
        if period_id is None:
            continue
        
        # Calculate hours for this period
        c.execute("""
            SELECT start_time, end_time FROM sessions
            WHERE period_id = ? AND end_time IS NOT NULL
            ORDER BY start_time
        """, (period_id,))
        
        sessions = c.fetchall()
        period_hours = sum(calculate_hours(s[0], s[1]) for s in sessions)
        
        status = "Completed" if end else "Active"
        client_totals[client_name]['periods'].append({
            'id': period_id,
            'start': start,
            'end': end,
            'hours': period_hours,
            'status': status
        })
        client_totals[client_name]['total'] += period_hours
    
    conn.close()
    
    if not client_totals:
        print("No billing data found")
        return
    
    print("\n" + "="*60)
    for client, data in sorted(client_totals.items()):
        print(f"\n{client}")
        print("-" * 60)
        
        if not data['periods']:
            print("  No billing periods")
        else:
            for period in data['periods']:
                start_date = datetime.fromisoformat(period['start']).strftime('%Y-%m-%d %H:%M')
                print(f"  Period #{period['id']} - {period['status']}")
                print(f"    Started: {start_date}")
                print(f"    Hours: {period['hours']:.2f}")
        
        print(f"\n  TOTAL: {data['total']:.2f} hours")
    print("="*60 + "\n")

def parse_time_string(time_str):
    """Parse time string in H:MM or HH:MM format to hours"""
    try:
        if ':' not in time_str:
            return float(time_str)
        
        parts = time_str.split(':')
        if len(parts) != 2:
            raise ValueError("Invalid time format")
        
        hours = int(parts[0])
        minutes = int(parts[1])
        
        if minutes < 0 or minutes > 59:
            raise ValueError("Minutes must be between 0 and 59")
        
        return hours + (minutes / 60.0)
    except (ValueError, IndexError):
        raise ValueError("Invalid time format. Use H:MM or HH:MM")

def adjust_time(client_name, adjustment_hours, operation):
    """Add or subtract time from the active period"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("SELECT id FROM clients WHERE name = ?", (client_name,))
    client = c.fetchone()
    
    if not client:
        print(f"✗ Client '{client_name}' not found")
        conn.close()
        return
    
    client_id = client[0]
    
    # Get active period
    c.execute("""SELECT id FROM periods 
                 WHERE client_id = ? AND end_time IS NULL""", (client_id,))
    period = c.fetchone()
    
    if not period:
        print(f"✗ No active billing period for '{client_name}'")
        conn.close()
        return
    
    period_id = period[0]
    
    # Calculate current total hours
    current_hours = get_period_total_hours(client_name)
    
    if operation == "subtract":
        new_hours = max(0, current_hours - adjustment_hours)
        adjustment_hours = current_hours - new_hours  # Actual adjustment made
    else:  # add
        new_hours = current_hours + adjustment_hours
    
    # Calculate the time difference in seconds
    time_diff_seconds = int((new_hours - current_hours) * 3600)
    
    if time_diff_seconds == 0:
        print(f"✓ No adjustment made (would result in negative time)")
        conn.close()
        return
    
    # Create an adjustment session
    now = datetime.now().isoformat()
    start_time = datetime.now()
    
    if time_diff_seconds > 0:
        # Add time: create a completed session with the duration
        end_time = start_time
        start_time = datetime.fromtimestamp(start_time.timestamp() - time_diff_seconds)
        
        c.execute("INSERT INTO sessions (period_id, start_time, end_time) VALUES (?, ?, ?)", 
                  (period_id, start_time.isoformat(), end_time.isoformat()))
        print(f"✓ Added {format_time(adjustment_hours)} to '{client_name}'")
    else:
        # Subtract time: remove the most recent completed sessions
        remaining_to_remove = abs(time_diff_seconds)
        
        c.execute("""
            SELECT id, start_time, end_time FROM sessions
            WHERE period_id = ? AND end_time IS NOT NULL
            ORDER BY end_time DESC
        """, (period_id,))
        
        sessions = c.fetchall()
        
        for session_id, start, end in sessions:
            if remaining_to_remove <= 0:
                break
            
            session_duration = int(calculate_hours(start, end) * 3600)
            
            if session_duration <= remaining_to_remove:
                # Remove entire session
                c.execute("DELETE FROM sessions WHERE id = ?", (session_id,))
                remaining_to_remove -= session_duration
            else:
                # Partially remove session by shortening it
                new_duration = session_duration - remaining_to_remove
                start_dt = datetime.fromisoformat(start)
                new_end = start_dt.timestamp() + new_duration
                new_end_iso = datetime.fromtimestamp(new_end).isoformat()
                
                c.execute("UPDATE sessions SET end_time = ? WHERE id = ?", 
                          (new_end_iso, session_id))
                remaining_to_remove = 0
        
        print(f"✓ Subtracted {format_time(adjustment_hours)} from '{client_name}'")
    
    conn.commit()
    conn.close()

def show_usage():
    print("""
Billable Hours Tracker

Usage:
  billable add <client>          Add a new client
  billable clients               List all clients
  billable start <client>        Start a billing period for a client
  billable session <client>       Open interactive timer (ENTER=play/pause, CTRL+D=exit)
  billable time <client> --add <time>     Add time to active period (e.g. 1:30 for 1hr 30min)
  billable time <client> --subtract <time> Subtract time from active period
  billable end <client>          End the billing period
  billable list                  Show hours for all clients
  billable help                  Show this help message

Quick workflow:
  1. billable add "Acme Corp"
  2. billable start "Acme Corp"
  3. billable session "Acme Corp"
     - Press ENTER to start/pause timer
     - Press CTRL+D to exit and pause
  4. billable end "Acme Corp"
  5. billable list
""")

def main():
    init_db()
    
    if len(sys.argv) < 2:
        show_usage()
        return
    
    command = sys.argv[1].lower()
    
    if command == 'add' and len(sys.argv) == 3:
        add_client(sys.argv[2])
    elif command == 'clients':
        list_clients()
    elif command == 'start' and len(sys.argv) == 3:
        start_period(sys.argv[2])
    elif command == 'session' and len(sys.argv) == 3:
        toggle_session(sys.argv[2])
    elif command == 'time' and len(sys.argv) == 5:
        client_name = sys.argv[2]
        operation_flag = sys.argv[3]
        time_str = sys.argv[4]
        
        if operation_flag == '--add':
            operation = 'add'
        elif operation_flag == '--subtract':
            operation = 'subtract'
        else:
            print("✗ Invalid flag. Use --add or --subtract")
            show_usage()
            return
        
        try:
            adjustment_hours = parse_time_string(time_str)
            adjust_time(client_name, adjustment_hours, operation)
        except ValueError as e:
            print(f"✗ {e}")
    elif command == 'end' and len(sys.argv) == 3:
        end_period(sys.argv[2])
    elif command == 'list':
        list_hours()
    elif command == 'help':
        show_usage()
    else:
        show_usage()

if __name__ == '__main__':
    main()

#!/usr/bin/env python3
import sqlite3
import sys
import os
from datetime import datetime
from pathlib import Path

DB_PATH = Path.home() / '.billable_hours.db'

def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS clients
                 (id INTEGER PRIMARY KEY, name TEXT UNIQUE)''')
    c.execute('''CREATE TABLE IF NOT EXISTS periods
                 (id INTEGER PRIMARY KEY, client_id INTEGER, 
                  start_time TEXT, end_time TEXT,
                  total_seconds INTEGER DEFAULT 0,
                  FOREIGN KEY(client_id) REFERENCES clients(id))''')
    conn.commit()
    conn.close()

def add_client(name):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    try:
        c.execute("INSERT INTO clients (name) VALUES (?)", (name,))
        conn.commit()
        print(f"✓ Client '{name}' added")
    except sqlite3.IntegrityError:
        print(f"✗ Client '{name}' already exists")
    conn.close()

def list_clients():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT id, name FROM clients ORDER BY name")
    clients = c.fetchall()
    conn.close()
    
    if not clients:
        print("No clients found. Add one with: billable add <client_name>")
        return
    
    print("\nClients:")
    for cid, name in clients:
        print(f"  {cid}. {name}")
    print()

def start_period(client_name):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("SELECT id FROM clients WHERE name = ?", (client_name,))
    client = c.fetchone()
    
    if not client:
        print(f"✗ Client '{client_name}' not found")
        conn.close()
        return
    
    client_id = client[0]
    
    # Check for active period
    c.execute("""SELECT id FROM periods 
                 WHERE client_id = ? AND end_time IS NULL""", (client_id,))
    if c.fetchone():
        print(f"✗ Client '{client_name}' already has an active billing period")
        conn.close()
        return
    
    now = datetime.now().isoformat()
    c.execute("INSERT INTO periods (client_id, start_time) VALUES (?, ?)", 
              (client_id, now))
    conn.commit()
    print(f"✓ Started billing period for '{client_name}'")
    conn.close()


def format_time(hours):
    """Format hours as HH:MM:SS"""
    total_seconds = int(hours * 3600)
    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    seconds = total_seconds % 60
    return f"{hours:02d}:{minutes:02d}:{seconds:02d}"

def get_period_total_hours(client_name):
    """Calculate total hours for the active period"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("SELECT id FROM clients WHERE name = ?", (client_name,))
    client = c.fetchone()
    
    if not client:
        conn.close()
        return 0
    
    client_id = client[0]
    
    # Get active period
    c.execute("""SELECT total_seconds FROM periods 
                 WHERE client_id = ? AND end_time IS NULL""", (client_id,))
    period = c.fetchone()
    
    if not period:
        conn.close()
        return 0
    
    total_hours = period[0] / 3600
    
    conn.close()
    return total_hours

# display_status function removed - now handled within toggle_session

def toggle_session(client_name):
    """Interactive toggle mode - press enter to toggle, Ctrl+D to exit"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("SELECT id FROM clients WHERE name = ?", (client_name,))
    client = c.fetchone()
    
    if not client:
        print(f"✗ Client '{client_name}' not found")
        conn.close()
        return
    
    client_id = client[0]
    
    # Get or check active period
    c.execute("""SELECT id FROM periods 
                 WHERE client_id = ? AND end_time IS NULL""", (client_id,))
    period = c.fetchone()
    
    if not period:
        print(f"✗ No active billing period for '{client_name}'")
        print(f"Start one with: billable start \"{client_name}\"")
        conn.close()
        return
    
    period_id = period[0]
    conn.close()
    
    # Local session state for this interactive session
    session_running = False
    session_start_time = None
    
    # Set stdin to non-blocking for running state
    import fcntl
    import time
    
    fd = sys.stdin.fileno()
    old_flags = fcntl.fcntl(fd, fcntl.F_GETFL)
    
    def display_session_status():
        """Display the timer UI with local session state"""
        total_hours = get_period_total_hours(client_name)
        
        # Add current session time if running
        if session_running and session_start_time:
            current_session_hours = (datetime.now() - session_start_time).total_seconds() / 3600
            total_hours += current_session_hours
        
        # Clear screen and show header
        print("\033[2J\033[H")  # Clear screen and move cursor to top
        print("="*60)
        print(f"  Billable Timer: {client_name}")
        print("="*60)
        print("\n  Controls:")
        print("    [ENTER]  - Play/Pause timer")
        print("    [CTRL+D] - End session and exit")
        print("\n" + "-"*60 + "\n")
        
        if session_running:
            print("  Status: ▶  RUNNING")
        else:
            print("  Status: ⏸  PAUSED")
        
        print(f"\n  Total Time: {format_time(total_hours)}")
        
        print("\n" + "-"*60)
        print("\nPress ENTER to play/pause...")
    
    # Initial display
    display_session_status()
    
    try:
        last_update = time.time()
        
        while True:
            if session_running:
                # Non-blocking mode when running
                fcntl.fcntl(fd, fcntl.F_SETFL, old_flags | os.O_NONBLOCK)
                
                try:
                    line = sys.stdin.readline()
                    if line:
                        # Pause - save accumulated time
                        if session_start_time:
                            session_duration_seconds = int((datetime.now() - session_start_time).total_seconds())
                            # Add this session time to the period's total_seconds
                            conn = sqlite3.connect(DB_PATH)
                            c = conn.cursor()
                            c.execute("""UPDATE periods SET total_seconds = 
                                        COALESCE(total_seconds, 0) + ? 
                                        WHERE id = ?""", (session_duration_seconds, period_id))
                            conn.commit()
                            conn.close()
                        
                        session_running = False
                        session_start_time = None
                        display_session_status()
                        last_update = time.time()
                except IOError:
                    # No input available
                    pass
                
                # Update display every second
                current_time = time.time()
                if current_time - last_update >= 1:
                    display_session_status()
                    last_update = current_time
                
                time.sleep(0.1)  # Small sleep to prevent busy waiting
                
            else:
                # Blocking mode when paused
                fcntl.fcntl(fd, fcntl.F_SETFL, old_flags)
                
                try:
                    line = sys.stdin.readline()
                    if line:
                        # Start timer
                        session_running = True
                        session_start_time = datetime.now()
                        display_session_status()
                        last_update = time.time()
                    else:
                        # EOF (Ctrl+D) - save any accumulated time and exit
                        if session_running and session_start_time:
                            session_duration_seconds = int((datetime.now() - session_start_time).total_seconds())
                            conn = sqlite3.connect(DB_PATH)
                            c = conn.cursor()
                            c.execute("""UPDATE periods SET total_seconds = 
                                        COALESCE(total_seconds, 0) + ? 
                                        WHERE id = ?""", (session_duration_seconds, period_id))
                            conn.commit()
                            conn.close()
                        print("\n\n✓ Session ended\n")
                        break
                except EOFError:
                    # Save any running session before exit
                    if session_running and session_start_time:
                        session_duration_seconds = int((datetime.now() - session_start_time).total_seconds())
                        conn = sqlite3.connect(DB_PATH)
                        c = conn.cursor()
                        c.execute("""UPDATE periods SET total_seconds = 
                                    COALESCE(total_seconds, 0) + ? 
                                    WHERE id = ?""", (session_duration_seconds, period_id))
                        conn.commit()
                        conn.close()
                    print("\n\n✓ Session ended\n")
                    break
                
    except KeyboardInterrupt:
        # Save any running session before exit
        if session_running and session_start_time:
            session_duration_seconds = int((datetime.now() - session_start_time).total_seconds())
            conn = sqlite3.connect(DB_PATH)
            c = conn.cursor()
            c.execute("""UPDATE periods SET total_seconds = 
                        COALESCE(total_seconds, 0) + ? 
                        WHERE id = ?""", (session_duration_seconds, period_id))
            conn.commit()
            conn.close()
        print("\n\n✓ Session ended\n")
    finally:
        # Restore original flags
        fcntl.fcntl(fd, fcntl.F_SETFL, old_flags)

def end_period(client_name):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("SELECT id FROM clients WHERE name = ?", (client_name,))
    client = c.fetchone()
    
    if not client:
        print(f"✗ Client '{client_name}' not found")
        conn.close()
        return
    
    client_id = client[0]
    
    # Get active period
    c.execute("""SELECT id FROM periods 
                 WHERE client_id = ? AND end_time IS NULL""", (client_id,))
    period = c.fetchone()
    
    if not period:
        print(f"✗ No active billing period for '{client_name}'")
        conn.close()
        return
    
    period_id = period[0]
    
    # End the period
    now = datetime.now().isoformat()
    c.execute("UPDATE periods SET end_time = ? WHERE id = ?", (now, period_id))
    conn.commit()
    print(f"✓ Ended billing period for '{client_name}'")
    conn.close()

def list_hours():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("""
        SELECT c.name, p.id, p.start_time, p.end_time, p.total_seconds
        FROM clients c
        LEFT JOIN periods p ON c.id = p.client_id
        ORDER BY c.name, p.start_time
    """)
    
    periods = c.fetchall()
    
    client_totals = {}
    
    for client_name, period_id, start, end, total_seconds in periods:
        if client_name not in client_totals:
            client_totals[client_name] = {'total': 0, 'periods': []}
        
        if period_id is None:
            continue
        
        # Convert total_seconds to hours
        period_hours = (total_seconds or 0) / 3600
        
        status = "Completed" if end else "Active"
        client_totals[client_name]['periods'].append({
            'id': period_id,
            'start': start,
            'end': end,
            'hours': period_hours,
            'status': status
        })
        client_totals[client_name]['total'] += period_hours
    
    conn.close()
    
    if not client_totals:
        print("No billing data found")
        return
    
    print("\n" + "="*60)
    for client, data in sorted(client_totals.items()):
        print(f"\n{client}")
        print("-" * 60)
        
        if not data['periods']:
            print("  No billing periods")
        else:
            for period in data['periods']:
                start_date = datetime.fromisoformat(period['start']).strftime('%Y-%m-%d %H:%M')
                print(f"  Period #{period['id']} - {period['status']}")
                print(f"    Started: {start_date}")
                print(f"    Hours: {format_time(period['hours'])}")
        
        print(f"\n  TOTAL: {format_time(data['total'])}")
    print("="*60 + "\n")

def parse_time_string(time_str):
    """Parse time string in H:MM or HH:MM format to hours"""
    try:
        if ':' not in time_str:
            return float(time_str)
        
        parts = time_str.split(':')
        if len(parts) != 2:
            raise ValueError("Invalid time format")
        
        hours = int(parts[0])
        minutes = int(parts[1])
        
        if minutes < 0 or minutes > 59:
            raise ValueError("Minutes must be between 0 and 59")
        
        return hours + (minutes / 60.0)
    except (ValueError, IndexError):
        raise ValueError("Invalid time format. Use H:MM or HH:MM")

def adjust_time(client_name, adjustment_hours, operation):
    """Add or subtract time from the active period"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("SELECT id FROM clients WHERE name = ?", (client_name,))
    client = c.fetchone()
    
    if not client:
        print(f"✗ Client '{client_name}' not found")
        conn.close()
        return
    
    client_id = client[0]
    
    # Get active period
    c.execute("""SELECT id, total_seconds FROM periods 
                 WHERE client_id = ? AND end_time IS NULL""", (client_id,))
    period = c.fetchone()
    
    if not period:
        print(f"✗ No active billing period for '{client_name}'")
        conn.close()
        return
    
    period_id, current_total_seconds = period
    current_total_seconds = current_total_seconds or 0
    
    # Calculate adjustment in seconds
    adjustment_seconds = int(adjustment_hours * 3600)
    
    if operation == "subtract":
        new_total_seconds = max(0, current_total_seconds - adjustment_seconds)
        actual_adjustment = current_total_seconds - new_total_seconds
    else:  # add
        new_total_seconds = current_total_seconds + adjustment_seconds
        actual_adjustment = adjustment_seconds
    
    if actual_adjustment == 0:
        print(f"✓ No adjustment made (would result in negative time)")
        conn.close()
        return
    
    # Update the total_seconds directly
    c.execute("UPDATE periods SET total_seconds = ? WHERE id = ?", (new_total_seconds, period_id))
    
    actual_hours = actual_adjustment / 3600
    if operation == "subtract":
        print(f"✓ Subtracted {format_time(actual_hours)} from '{client_name}'")
    else:
        print(f"✓ Added {format_time(actual_hours)} to '{client_name}'")
    
    conn.commit()
    conn.close()

def show_usage():
    print("""
Billable Hours Tracker

Usage:
  billable add <client>          Add a new client
  billable clients               List all clients
  billable start <client>        Start a billing period for a client
  billable session <client>       Open interactive timer (ENTER=play/pause, CTRL+D=exit)
  billable adjust <client> --add <time>     Add time to active period (e.g. 1:30 for 1hr 30min)
  billable adjust <client> --subtract <time> Subtract time from active period
  billable end <client>          End the billing period
  billable list                  Show hours for all clients
  billable help                  Show this help message

Quick workflow:
  1. billable add "Acme Corp"
  2. billable start "Acme Corp"
  3. billable session "Acme Corp"
     - Press ENTER to start/pause timer
     - Press CTRL+D to exit and pause
  4. billable end "Acme Corp"
  5. billable list
""")

def main():
    init_db()
    
    if len(sys.argv) < 2:
        show_usage()
        return
    
    command = sys.argv[1].lower()
    
    if command == 'add' and len(sys.argv) == 3:
        add_client(sys.argv[2])
    elif command == 'clients':
        list_clients()
    elif command == 'start' and len(sys.argv) == 3:
        start_period(sys.argv[2])
    elif command == 'session' and len(sys.argv) == 3:
        toggle_session(sys.argv[2])
    elif command == 'adjust' and len(sys.argv) == 5:
        client_name = sys.argv[2]
        operation_flag = sys.argv[3]
        time_str = sys.argv[4]
        
        if operation_flag == '--add':
            operation = 'add'
        elif operation_flag == '--subtract':
            operation = 'subtract'
        else:
            print("✗ Invalid flag. Use --add or --subtract")
            show_usage()
            return
        
        try:
            adjustment_hours = parse_time_string(time_str)
            adjust_time(client_name, adjustment_hours, operation)
        except ValueError as e:
            print(f"✗ {e}")
    elif command == 'end' and len(sys.argv) == 3:
        end_period(sys.argv[2])
    elif command == 'list':
        list_hours()
    elif command == 'help':
        show_usage()
    else:
        show_usage()

if __name__ == '__main__':
    main()

#!/usr/bin/env python3
import sqlite3
import sys
import os
import re
from datetime import datetime
from pathlib import Path

DB_PATH = Path.home() / '.billable_hours.db'

def validate_client_name(name):
    """Validate client name input"""
    if not name:
        raise ValueError("Client name cannot be empty")
    
    if not isinstance(name, str):
        raise ValueError("Client name must be a string")
    
    name = name.strip()
    if not name:
        raise ValueError("Client name cannot be empty or only whitespace")
    
    if len(name) > 255:
        raise ValueError("Client name cannot exceed 255 characters")
    
    # Check for potentially problematic characters
    if any(char in name for char in ['\n', '\r', '\t']):
        raise ValueError("Client name cannot contain newlines or tabs")
    
    # Check for SQL injection patterns (basic protection)
    suspicious_patterns = [
        r'[\'";]',  # Quote characters
        r'--',      # SQL comments
        r'/\*',     # Multi-line comments
        r'\*/',
    ]
    
    for pattern in suspicious_patterns:
        if re.search(pattern, name, re.IGNORECASE):
            raise ValueError("Client name contains invalid characters")
    
    return name

def validate_command_args(command, args):
    """Validate command line arguments"""
    expected_args = {
        'add': 1,
        'start': 1,
        'session': 1,
        'end': 1,
        'adjust': 3,  # client, flag, time
        'clients': 0,
        'list': 0,
        'help': 0
    }
    
    if command not in expected_args:
        raise ValueError(f"Unknown command: {command}")
    
    expected_count = expected_args[command]
    actual_count = len(args)
    
    if actual_count != expected_count:
        if command == 'adjust':
            raise ValueError(f"Command '{command}' requires {expected_count} arguments: <client> <--add|--subtract> <time>")
        elif expected_count == 0:
            if actual_count > 0:
                raise ValueError(f"Command '{command}' takes no arguments")
        else:
            raise ValueError(f"Command '{command}' requires exactly {expected_count} argument(s)")

def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS clients
                 (id INTEGER PRIMARY KEY, name TEXT UNIQUE)''')
    c.execute('''CREATE TABLE IF NOT EXISTS periods
                 (id INTEGER PRIMARY KEY, client_id INTEGER, 
                  start_time TEXT, end_time TEXT,
                  total_seconds INTEGER DEFAULT 0,
                  FOREIGN KEY(client_id) REFERENCES clients(id))''')
    conn.commit()
    conn.close()

def add_client(name):
    try:
        validated_name = validate_client_name(name)
    except ValueError as e:
        print(f"✗ {e}")
        return
    
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    try:
        c.execute("INSERT INTO clients (name) VALUES (?)", (validated_name,))
        conn.commit()
        print(f"✓ Client '{validated_name}' added")
    except sqlite3.IntegrityError:
        print(f"✗ Client '{validated_name}' already exists")
    except sqlite3.Error as e:
        print(f"✗ Database error: {e}")
    finally:
        conn.close()

def list_clients():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT id, name FROM clients ORDER BY name")
    clients = c.fetchall()
    conn.close()
    
    if not clients:
        print("No clients found. Add one with: billable add <client_name>")
        return
    
    print("\nClients:")
    for cid, name in clients:
        print(f"  {cid}. {name}")
    print()

def start_period(client_name):
    try:
        validated_name = validate_client_name(client_name)
    except ValueError as e:
        print(f"✗ {e}")
        return
    
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    try:
        c.execute("SELECT id FROM clients WHERE name = ?", (validated_name,))
        client = c.fetchone()
        
        if not client:
            print(f"✗ Client '{validated_name}' not found")
            return
        
        client_id = client[0]
        
        # Check for active period
        c.execute("""SELECT id FROM periods 
                     WHERE client_id = ? AND end_time IS NULL""", (client_id,))
        if c.fetchone():
            print(f"✗ Client '{validated_name}' already has an active billing period")
            return
        
        now = datetime.now().isoformat()
        c.execute("INSERT INTO periods (client_id, start_time) VALUES (?, ?)", 
                  (client_id, now))
        conn.commit()
        print(f"✓ Started billing period for '{validated_name}'")
    except sqlite3.Error as e:
        print(f"✗ Database error: {e}")
    finally:
        conn.close()


def format_time(hours):
    """Format hours as HH:MM:SS"""
    total_seconds = int(hours * 3600)
    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    seconds = total_seconds % 60
    return f"{hours:02d}:{minutes:02d}:{seconds:02d}"

def get_period_total_hours(client_name):
    """Calculate total hours for the active period"""
    try:
        validated_name = validate_client_name(client_name)
    except ValueError:
        return 0
    
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    try:
        c.execute("SELECT id FROM clients WHERE name = ?", (validated_name,))
        client = c.fetchone()
        
        if not client:
            return 0
        
        client_id = client[0]
        
        # Get active period
        c.execute("""SELECT total_seconds FROM periods 
                     WHERE client_id = ? AND end_time IS NULL""", (client_id,))
        period = c.fetchone()
        
        if not period:
            return 0
        
        total_hours = (period[0] or 0) / 3600
        return total_hours
    except sqlite3.Error:
        return 0
    finally:
        conn.close()

# display_status function removed - now handled within toggle_session

def toggle_session(client_name):
    """Interactive toggle mode - press enter to toggle, Ctrl+D to exit"""
    try:
        validated_name = validate_client_name(client_name)
    except ValueError as e:
        print(f"✗ {e}")
        return
    
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    try:
        c.execute("SELECT id FROM clients WHERE name = ?", (validated_name,))
        client = c.fetchone()
        
        if not client:
            print(f"✗ Client '{validated_name}' not found")
            return
        
        client_id = client[0]
        
        # Get or check active period
        c.execute("""SELECT id FROM periods 
                     WHERE client_id = ? AND end_time IS NULL""", (client_id,))
        period = c.fetchone()
        
        if not period:
            print(f"✗ No active billing period for '{validated_name}'")
            print(f"Start one with: billable start \"{validated_name}\"")
            return
        
        period_id = period[0]
    except sqlite3.Error as e:
        print(f"✗ Database error: {e}")
        return
    finally:
        conn.close()
    
    # Local session state for this interactive session
    session_running = False
    session_start_time = None
    
    # Set stdin to non-blocking for running state
    import fcntl
    import time
    
    fd = sys.stdin.fileno()
    old_flags = fcntl.fcntl(fd, fcntl.F_GETFL)
    
    def display_session_status():
        """Display the timer UI with local session state"""
        total_hours = get_period_total_hours(validated_name)
        
        # Add current session time if running
        if session_running and session_start_time:
            current_session_hours = (datetime.now() - session_start_time).total_seconds() / 3600
            total_hours += current_session_hours
        
        # Clear screen and show header
        print("\033[2J\033[H")  # Clear screen and move cursor to top
        print("="*60)
        print(f"  Billable Timer: {validated_name}")
        print("="*60)
        print("\n  Controls:")
        print("    [ENTER]  - Play/Pause timer")
        print("    [CTRL+D] - End session and exit")
        print("\n" + "-"*60 + "\n")
        
        if session_running:
            print("  Status: ▶  RUNNING")
        else:
            print("  Status: ⏸  PAUSED")
        
        print(f"\n  Total Time: {format_time(total_hours)}")
        
        print("\n" + "-"*60)
        print("\nPress ENTER to play/pause...")
    
    # Initial display
    display_session_status()
    
    try:
        last_update = time.time()
        
        while True:
            if session_running:
                # Non-blocking mode when running
                fcntl.fcntl(fd, fcntl.F_SETFL, old_flags | os.O_NONBLOCK)
                
                try:
                    line = sys.stdin.readline()
                    if line:
                        # Pause - save accumulated time
                        if session_start_time:
                            session_duration_seconds = int((datetime.now() - session_start_time).total_seconds())
                            # Add this session time to the period's total_seconds
                            conn = sqlite3.connect(DB_PATH)
                            c = conn.cursor()
                            c.execute("""UPDATE periods SET total_seconds = 
                                        COALESCE(total_seconds, 0) + ? 
                                        WHERE id = ?""", (session_duration_seconds, period_id))
                            conn.commit()
                            conn.close()
                        
                        session_running = False
                        session_start_time = None
                        display_session_status()
                        last_update = time.time()
                except IOError:
                    # No input available
                    pass
                
                # Update display every second
                current_time = time.time()
                if current_time - last_update >= 1:
                    display_session_status()
                    last_update = current_time
                
                time.sleep(0.1)  # Small sleep to prevent busy waiting
                
            else:
                # Blocking mode when paused
                fcntl.fcntl(fd, fcntl.F_SETFL, old_flags)
                
                try:
                    line = sys.stdin.readline()
                    if line:
                        # Start timer
                        session_running = True
                        session_start_time = datetime.now()
                        display_session_status()
                        last_update = time.time()
                    else:
                        # EOF (Ctrl+D) - save any accumulated time and exit
                        if session_running and session_start_time:
                            session_duration_seconds = int((datetime.now() - session_start_time).total_seconds())
                            conn = sqlite3.connect(DB_PATH)
                            c = conn.cursor()
                            c.execute("""UPDATE periods SET total_seconds = 
                                        COALESCE(total_seconds, 0) + ? 
                                        WHERE id = ?""", (session_duration_seconds, period_id))
                            conn.commit()
                            conn.close()
                        print("\n\n✓ Session ended\n")
                        break
                except EOFError:
                    # Save any running session before exit
                    if session_running and session_start_time:
                        session_duration_seconds = int((datetime.now() - session_start_time).total_seconds())
                        conn = sqlite3.connect(DB_PATH)
                        c = conn.cursor()
                        c.execute("""UPDATE periods SET total_seconds = 
                                    COALESCE(total_seconds, 0) + ? 
                                    WHERE id = ?""", (session_duration_seconds, period_id))
                        conn.commit()
                        conn.close()
                    print("\n\n✓ Session ended\n")
                    break
                
    except KeyboardInterrupt:
        # Save any running session before exit
        if session_running and session_start_time:
            session_duration_seconds = int((datetime.now() - session_start_time).total_seconds())
            conn = sqlite3.connect(DB_PATH)
            c = conn.cursor()
            c.execute("""UPDATE periods SET total_seconds = 
                        COALESCE(total_seconds, 0) + ? 
                        WHERE id = ?""", (session_duration_seconds, period_id))
            conn.commit()
            conn.close()
        print("\n\n✓ Session ended\n")
    finally:
        # Restore original flags
        fcntl.fcntl(fd, fcntl.F_SETFL, old_flags)

def end_period(client_name):
    try:
        validated_name = validate_client_name(client_name)
    except ValueError as e:
        print(f"✗ {e}")
        return
    
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    try:
        c.execute("SELECT id FROM clients WHERE name = ?", (validated_name,))
        client = c.fetchone()
        
        if not client:
            print(f"✗ Client '{validated_name}' not found")
            return
        
        client_id = client[0]
        
        # Get active period
        c.execute("""SELECT id FROM periods 
                     WHERE client_id = ? AND end_time IS NULL""", (client_id,))
        period = c.fetchone()
        
        if not period:
            print(f"✗ No active billing period for '{validated_name}'")
            return
        
        period_id = period[0]
        
        # End the period
        now = datetime.now().isoformat()
        c.execute("UPDATE periods SET end_time = ? WHERE id = ?", (now, period_id))
        conn.commit()
        print(f"✓ Ended billing period for '{validated_name}'")
    except sqlite3.Error as e:
        print(f"✗ Database error: {e}")
    finally:
        conn.close()

def list_hours():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute("""
        SELECT c.name, p.id, p.start_time, p.end_time, p.total_seconds
        FROM clients c
        LEFT JOIN periods p ON c.id = p.client_id
        ORDER BY c.name, p.start_time
    """)
    
    periods = c.fetchall()
    
    client_totals = {}
    
    for client_name, period_id, start, end, total_seconds in periods:
        if client_name not in client_totals:
            client_totals[client_name] = {'total': 0, 'periods': []}
        
        if period_id is None:
            continue
        
        # Convert total_seconds to hours
        period_hours = (total_seconds or 0) / 3600
        
        status = "Completed" if end else "Active"
        client_totals[client_name]['periods'].append({
            'id': period_id,
            'start': start,
            'end': end,
            'hours': period_hours,
            'status': status
        })
        client_totals[client_name]['total'] += period_hours
    
    conn.close()
    
    if not client_totals:
        print("No billing data found")
        return
    
    print("\n" + "="*60)
    for client, data in sorted(client_totals.items()):
        print(f"\n{client}")
        print("-" * 60)
        
        if not data['periods']:
            print("  No billing periods")
        else:
            for period in data['periods']:
                start_date = datetime.fromisoformat(period['start']).strftime('%Y-%m-%d %H:%M')
                print(f"  Period #{period['id']} - {period['status']}")
                print(f"    Started: {start_date}")
                print(f"    Hours: {format_time(period['hours'])}")
        
        print(f"\n  TOTAL: {format_time(data['total'])}")
    print("="*60 + "\n")

def parse_time_string(time_str):
    """Parse time string in H:MM or HH:MM format to hours"""
    if not time_str or not isinstance(time_str, str):
        raise ValueError("Time must be a non-empty string")
    
    time_str = time_str.strip()
    if not time_str:
        raise ValueError("Time cannot be empty or only whitespace")
    
    # Check for potentially malicious input
    if any(char in time_str for char in [';', '&', '|', '`', '$', '<', '>', '"', "'"]):
        raise ValueError("Time contains invalid characters")
    
    try:
        if ':' not in time_str:
            hours = float(time_str)
            if hours < 0:
                raise ValueError("Time cannot be negative")
            if hours > 24:
                raise ValueError("Time cannot exceed 24 hours")
            return hours
        
        parts = time_str.split(':')
        if len(parts) != 2:
            raise ValueError("Invalid time format")
        
        hours = int(parts[0])
        minutes = int(parts[1])
        
        if hours < 0:
            raise ValueError("Hours cannot be negative")
        if hours > 23:
            raise ValueError("Hours cannot exceed 23")
        if minutes < 0 or minutes > 59:
            raise ValueError("Minutes must be between 0 and 59")
        
        return hours + (minutes / 60.0)
    except (ValueError, IndexError) as e:
        if "invalid literal" in str(e):
            raise ValueError("Invalid time format. Use H:MM or HH:MM")
        raise

def adjust_time(client_name, adjustment_hours, operation):
    """Add or subtract time from the active period"""
    try:
        validated_name = validate_client_name(client_name)
    except ValueError as e:
        print(f"✗ {e}")
        return
    
    if operation not in ["add", "subtract"]:
        print(f"✗ Invalid operation: {operation}")
        return
    
    if not isinstance(adjustment_hours, (int, float)) or adjustment_hours < 0:
        print(f"✗ Invalid adjustment hours: {adjustment_hours}")
        return
    
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    try:
        c.execute("SELECT id FROM clients WHERE name = ?", (validated_name,))
        client = c.fetchone()
        
        if not client:
            print(f"✗ Client '{validated_name}' not found")
            return
        
        client_id = client[0]
        
        # Get active period
        c.execute("""SELECT id, total_seconds FROM periods 
                     WHERE client_id = ? AND end_time IS NULL""", (client_id,))
        period = c.fetchone()
        
        if not period:
            print(f"✗ No active billing period for '{validated_name}'")
            return
        
        period_id, current_total_seconds = period
        current_total_seconds = current_total_seconds or 0
        
        # Calculate adjustment in seconds
        adjustment_seconds = int(adjustment_hours * 3600)
        
        if operation == "subtract":
            new_total_seconds = max(0, current_total_seconds - adjustment_seconds)
            actual_adjustment = current_total_seconds - new_total_seconds
        else:  # add
            new_total_seconds = current_total_seconds + adjustment_seconds
            actual_adjustment = adjustment_seconds
        
        if actual_adjustment == 0:
            print(f"✓ No adjustment made (would result in negative time)")
            return
        
        # Update the total_seconds directly
        c.execute("UPDATE periods SET total_seconds = ? WHERE id = ?", (new_total_seconds, period_id))
        
        actual_hours = actual_adjustment / 3600
        if operation == "subtract":
            print(f"✓ Subtracted {format_time(actual_hours)} from '{validated_name}'")
        else:
            print(f"✓ Added {format_time(actual_hours)} to '{validated_name}'")
        
        conn.commit()
    except sqlite3.Error as e:
        print(f"✗ Database error: {e}")
    finally:
        conn.close()

def show_usage():
    print("""
Billable Hours Tracker

Usage:
  billable add <client>          Add a new client
  billable clients               List all clients
  billable start <client>        Start a billing period for a client
  billable session <client>       Open interactive timer (ENTER=play/pause, CTRL+D=exit)
  billable adjust <client> --add <time>     Add time to active period (e.g. 1:30 for 1hr 30min)
  billable adjust <client> --subtract <time> Subtract time from active period
  billable end <client>          End the billing period
  billable list                  Show hours for all clients
  billable help                  Show this help message

Quick workflow:
  1. billable add "Acme Corp"
  2. billable start "Acme Corp"
  3. billable session "Acme Corp"
     - Press ENTER to start/pause timer
     - Press CTRL+D to exit and pause
  4. billable end "Acme Corp"
  5. billable list
""")

def main():
    try:
        init_db()
    except Exception as e:
        print(f"✗ Failed to initialize database: {e}")
        return
    
    if len(sys.argv) < 2:
        show_usage()
        return
    
    command = sys.argv[1].lower()
    args = sys.argv[2:]
    
    # Validate command and arguments
    try:
        validate_command_args(command, args)
    except ValueError as e:
        print(f"✗ {e}")
        show_usage()
        return
    
    # Execute commands
    try:
        if command == 'add':
            add_client(args[0])
        elif command == 'clients':
            list_clients()
        elif command == 'start':
            start_period(args[0])
        elif command == 'session':
            toggle_session(args[0])
        elif command == 'adjust':
            client_name = args[0]
            operation_flag = args[1]
            time_str = args[2]
            
            if operation_flag == '--add':
                operation = 'add'
            elif operation_flag == '--subtract':
                operation = 'subtract'
            else:
                print("✗ Invalid flag. Use --add or --subtract")
                show_usage()
                return
            
            try:
                adjustment_hours = parse_time_string(time_str)
                adjust_time(client_name, adjustment_hours, operation)
            except ValueError as e:
                print(f"✗ {e}")
        elif command == 'end':
            end_period(args[0])
        elif command == 'list':
            list_hours()
        elif command == 'help':
            show_usage()
    except KeyboardInterrupt:
        print("\n✓ Operation cancelled")
    except Exception as e:
        print(f"✗ Unexpected error: {e}")
        if "--debug" in sys.argv:
            import traceback
            traceback.print_exc()

if __name__ == '__main__':
    main()
